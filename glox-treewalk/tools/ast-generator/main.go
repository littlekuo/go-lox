package main

import (
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"strings"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

var initedTypes = map[string]struct{}{}

func generatedStructDef(writer io.Writer, structName string) error {
	if structName == "" ||
		structName == "any" ||
		structName == "error" {
		// builtin type
		return nil
	}
	if _, ok := initedTypes[structName]; ok {
		return nil
	}
	if structName == "Result" {
		resultStructDef := fmt.Sprintf("type %s struct {\n\t Value any \n\t Err error\n}\n", structName)
		if _, err := writer.Write([]byte(resultStructDef)); err != nil {
			return fmt.Errorf("failed to write result struct definition: %s", err.Error())
		}
		writer.Write([]byte("\n"))
	}
	initedTypes[structName] = struct{}{}
	return nil
}

func main() {
	if len(os.Args) < 2 {
		fmt.Fprintf(os.Stderr, "Usage: ast-generator <output directory>\n")
		os.Exit(64)
	}

	outputDir := os.Args[1]
	if err := defineAst(outputDir, "Expr", []string{
		"Assign   : Token name, Expr value",
		"Binary: Expr left, Token operator, Expr right",
		"Grouping: Expr expression",
		"Literal: any value",
		"Unary: Expr right, Token operator",
		"Variable : Token name",
	}, "Result"); err != nil {
		log.Fatal(err)
	}
	if err := defineAst(outputDir, "Stmt", []string{
		"Block      : []Stmt statements",
		"Expression : Expr expression",
		"Print      : Expr expression",
		"Var        : Token name, Expr initializer",
		"If         : Expr condition, Stmt thenBranch, Stmt elseBranch",
	}, "error"); err != nil {
		log.Fatal(err)
	}
}

func defineAst(outputDir string, baseName string, types []string, returnTypeName string) error {
	path := filepath.Join(outputDir, strings.ToLower(baseName)+".go")
	file, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("failed to create file: %s", err.Error())
	}
	defer file.Close()

	// write header
	header := "// Code generated by tool; DO NOT EDIT.\npackage syntax\n"
	if _, err = file.WriteString(header); err != nil {
		return fmt.Errorf("failed to write header: %s", err.Error())
	}
	file.WriteString("\n")

	if gErr := generatedStructDef(file, returnTypeName); gErr != nil {
		return gErr
	}
	// write visitor interface definition
	visitorInterface := fmt.Sprintf("type %sVisitor interface {\n", baseName)
	for _, typ := range types {
		parts := strings.Split(typ, ":")
		structName := strings.TrimSpace(parts[0])
		visitorInterface += fmt.Sprintf("\tVisit%s%s(*%s) %s\n", structName, baseName, structName, returnTypeName)
	}
	visitorInterface += "}\n"
	if _, err = file.WriteString(visitorInterface); err != nil {
		return fmt.Errorf("failed to write interface definition: %s", err.Error())
	}
	file.WriteString("\n")

	// write interface definition
	interfaceDef := fmt.Sprintf("type %s interface {\n\t Accept(%sVisitor) %s\n}\n", baseName, baseName, returnTypeName)
	if _, err = file.WriteString(interfaceDef); err != nil {
		return fmt.Errorf("failed to write interface definition: %s", err.Error())
	}
	file.WriteString("\n")

	// define struct
	for idx := range types {
		parts := strings.Split(types[idx], ":")
		structName := strings.TrimSpace(parts[0])
		fieldDefinitions := strings.TrimSpace(parts[1])
		defineType(file, baseName, structName, fieldDefinitions, returnTypeName)
		file.WriteString("\n")
	}

	return nil
}

func defineType(writer io.Writer, baseName, structName, fieldList, resultTypeName string) {
	// (example："Expr left, Token operator, Expr right"）
	fields := strings.Split(fieldList, ", ")

	fmt.Fprintf(writer, "type %s struct {\n", structName)
	for _, field := range fields {
		parts := strings.Split(field, " ")
		if len(parts) != 2 {
			log.Fatalf("invalid field definition: %s", field)
			continue
		}
		fieldType := parts[0]
		fieldName := cases.Title(language.English).String(parts[1])
		fmt.Fprintf(writer, "\t%s %s\n", fieldName, fieldType)
	}
	fmt.Fprintf(writer, "}\n")

	// 生成构造函数
	fmt.Fprintf(writer, "func New%s(", structName)
	params := make([]string, 0, len(fields))
	for _, field := range fields {
		parts := strings.Split(field, " ")
		params = append(params, strings.ToLower(parts[1])+" "+parts[0])
	}
	fmt.Fprintf(writer, "%s) *%s {\n", strings.Join(params, ", "), structName)
	fmt.Fprintf(writer, "\treturn &%s{\n", structName)
	for _, field := range fields {
		parts := strings.Split(field, " ")
		fieldName := cases.Title(language.English).String(parts[1])
		paramName := strings.ToLower(parts[1])
		fmt.Fprintf(writer, "\t\t%s: %s,\n", fieldName, paramName)
	}
	fmt.Fprintln(writer, "\t}")
	fmt.Fprintf(writer, "}\n")

	// 实现表达式接口
	fmt.Fprintf(writer, "func (n *%s) Accept(v %sVisitor) %s {\n", structName, baseName, resultTypeName)
	if resultTypeName != "" {
		fmt.Fprintf(writer, "\treturn v.Visit%s%s(n)\n", structName, baseName)
	} else {
		fmt.Fprintf(writer, "\tv.Visit%s%s(n)\n", structName, baseName)
	}
	fmt.Fprintf(writer, "}\n")
}
