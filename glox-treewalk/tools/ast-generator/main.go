package main

import (
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"strings"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

func main() {
	if len(os.Args) < 2 {
		fmt.Fprintf(os.Stderr, "Usage: ast-generator <output directory>\n")
		os.Exit(64)
	}

	outputDir := os.Args[1]
	if err := defineAst(outputDir, "Expr", []string{
		"Binary: Expr left, Token operator, Expr right",
		"Grouping: Expr expression",
		"Literal: any value",
		"Unary: Expr right, Token operator",
	}); err != nil {
		log.Fatal(err)
	}
}

func defineAst(outputDir string, baseName string, types []string) error {
	path := filepath.Join(outputDir, strings.ToLower(baseName)+".go")
	file, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("failed to create file: %s", err.Error())
	}
	defer file.Close()

	// write header
	header := "// Code generated by tool; DO NOT EDIT.\npackage syntax\n"
	if _, err = file.WriteString(header); err != nil {
		return fmt.Errorf("failed to write header: %s", err.Error())
	}
	file.WriteString("\n")

	// write result struct definition
	resultStructDef := "type Result struct {\n\t Value interface{}\n\t Err error\n}\n"
	if _, err = file.WriteString(resultStructDef); err != nil {
		return fmt.Errorf("failed to write result struct definition: %s", err.Error())
	}
	file.WriteString("\n")

	// write visitor interface definition
	visitorInterface := "type Visitor interface {\n"
	for _, typ := range types {
		parts := strings.Split(typ, ":")
		structName := strings.TrimSpace(parts[0])
		visitorInterface += fmt.Sprintf("\tVisit%s%s(*%s) Result\n", structName, baseName, structName)
	}
	visitorInterface += "}\n"
	if _, err = file.WriteString(visitorInterface); err != nil {
		return fmt.Errorf("failed to write interface definition: %s", err.Error())
	}
	file.WriteString("\n")

	// write interface definition
	interfaceDef := fmt.Sprintf("type %s interface {\n\t Accept(Visitor) Result\n}\n", baseName)
	if _, err = file.WriteString(interfaceDef); err != nil {
		return fmt.Errorf("failed to write interface definition: %s", err.Error())
	}
	file.WriteString("\n")

	// define struct
	for idx := range types {
		parts := strings.Split(types[idx], ":")
		structName := strings.TrimSpace(parts[0])
		fieldDefinitions := strings.TrimSpace(parts[1])
		defineType(file, baseName, structName, fieldDefinitions)
		file.WriteString("\n")
	}

	return nil
}

func defineType(writer io.Writer, baseName, structName, fieldList string) {
	// (example："Expr left, Token operator, Expr right"）
	fields := strings.Split(fieldList, ", ")

	fmt.Fprintf(writer, "type %s struct {\n", structName)
	for _, field := range fields {
		parts := strings.Split(field, " ")
		if len(parts) != 2 {
			log.Fatalf("invalid field definition: %s", field)
			continue
		}
		fieldType := parts[0]
		fieldName := cases.Title(language.English).String(parts[1])
		fmt.Fprintf(writer, "\t%s %s\n", fieldName, fieldType)
	}
	fmt.Fprintf(writer, "}\n")

	// 生成构造函数
	fmt.Fprintf(writer, "func New%s(", structName)
	params := make([]string, 0, len(fields))
	for _, field := range fields {
		parts := strings.Split(field, " ")
		params = append(params, strings.ToLower(parts[1])+" "+parts[0])
	}
	fmt.Fprintf(writer, "%s) *%s {\n", strings.Join(params, ", "), structName)
	fmt.Fprintf(writer, "\treturn &%s{\n", structName)
	for _, field := range fields {
		parts := strings.Split(field, " ")
		fieldName := cases.Title(language.English).String(parts[1])
		paramName := strings.ToLower(parts[1])
		fmt.Fprintf(writer, "\t\t%s: %s,\n", fieldName, paramName)
	}
	fmt.Fprintln(writer, "\t}")
	fmt.Fprintf(writer, "}\n")

	// 实现表达式接口
	fmt.Fprintf(writer, "func (n *%s) Accept(v Visitor) Result {\n", structName)
	fmt.Fprintf(writer, "\treturn v.Visit%s%s(n)\n", structName, baseName)
	fmt.Fprintf(writer, "}\n")
}
