// Code generated by tool; DO NOT EDIT.
package syntax

type StmtVisitor interface {
	VisitBlockStmt(*Block) error
	VisitExpressionStmt(*Expression) error
	VisitPrintStmt(*Print) error
	VisitVarStmt(*Var) error
	VisitFunctionStmt(*Function) error
	VisitIfStmt(*If) error
	VisitWhileStmt(*While) error
	VisitReturnStmt(*Return) error
	VisitBreakStmt(*Break) error
	VisitForDesugaredWhileStmt(*ForDesugaredWhile) error
	VisitContinueStmt(*Continue) error
	VisitClassStmt(*Class) error
}

type Stmt interface {
	 Accept(StmtVisitor) error
}

type Block struct {
	Statements []Stmt
}
func NewBlock(statements []Stmt) *Block {
	return &Block{
		Statements: statements,
	}
}
func (n *Block) Accept(v StmtVisitor) error {
	return v.VisitBlockStmt(n)
}

type Expression struct {
	Expression Expr
}
func NewExpression(expression Expr) *Expression {
	return &Expression{
		Expression: expression,
	}
}
func (n *Expression) Accept(v StmtVisitor) error {
	return v.VisitExpressionStmt(n)
}

type Print struct {
	Expression Expr
}
func NewPrint(expression Expr) *Print {
	return &Print{
		Expression: expression,
	}
}
func (n *Print) Accept(v StmtVisitor) error {
	return v.VisitPrintStmt(n)
}

type Var struct {
	Name Token
	Initializer Expr
}
func NewVar(name Token, initializer Expr) *Var {
	return &Var{
		Name: name,
		Initializer: initializer,
	}
}
func (n *Var) Accept(v StmtVisitor) error {
	return v.VisitVarStmt(n)
}

type Function struct {
	Name Token
	Params []Token
	Body []Stmt
}
func NewFunction(name Token, params []Token, body []Stmt) *Function {
	return &Function{
		Name: name,
		Params: params,
		Body: body,
	}
}
func (n *Function) Accept(v StmtVisitor) error {
	return v.VisitFunctionStmt(n)
}

type If struct {
	Condition Expr
	Thenbranch Stmt
	Elsebranch Stmt
}
func NewIf(condition Expr, thenbranch Stmt, elsebranch Stmt) *If {
	return &If{
		Condition: condition,
		Thenbranch: thenbranch,
		Elsebranch: elsebranch,
	}
}
func (n *If) Accept(v StmtVisitor) error {
	return v.VisitIfStmt(n)
}

type While struct {
	Condition Expr
	Body Stmt
}
func NewWhile(condition Expr, body Stmt) *While {
	return &While{
		Condition: condition,
		Body: body,
	}
}
func (n *While) Accept(v StmtVisitor) error {
	return v.VisitWhileStmt(n)
}

type Return struct {
	Keyword Token
	Value Expr
}
func NewReturn(keyword Token, value Expr) *Return {
	return &Return{
		Keyword: keyword,
		Value: value,
	}
}
func (n *Return) Accept(v StmtVisitor) error {
	return v.VisitReturnStmt(n)
}

type Break struct {
	Keyword Token
}
func NewBreak(keyword Token) *Break {
	return &Break{
		Keyword: keyword,
	}
}
func (n *Break) Accept(v StmtVisitor) error {
	return v.VisitBreakStmt(n)
}

type ForDesugaredWhile struct {
	Condition Expr
	Body Stmt
	Increment Expr
}
func NewForDesugaredWhile(condition Expr, body Stmt, increment Expr) *ForDesugaredWhile {
	return &ForDesugaredWhile{
		Condition: condition,
		Body: body,
		Increment: increment,
	}
}
func (n *ForDesugaredWhile) Accept(v StmtVisitor) error {
	return v.VisitForDesugaredWhileStmt(n)
}

type Continue struct {
	Keyword Token
}
func NewContinue(keyword Token) *Continue {
	return &Continue{
		Keyword: keyword,
	}
}
func (n *Continue) Accept(v StmtVisitor) error {
	return v.VisitContinueStmt(n)
}

type Class struct {
	Name Token
	Superclass *Variable
	Methods []*Function
}
func NewClass(name Token, superclass *Variable, methods []*Function) *Class {
	return &Class{
		Name: name,
		Superclass: superclass,
		Methods: methods,
	}
}
func (n *Class) Accept(v StmtVisitor) error {
	return v.VisitClassStmt(n)
}

